# 多线程

## notify和notifyAll的区别？
- notify(): notify()方法用于唤醒等待在对象监视器上的单个线程。如果有多个线程正在等待该监视器，由系统选择其中一个线程来唤醒，选择是非确定性的（具体哪个线程被唤醒是不可预测的）。

- notifyAll(): notifyAll()方法用于唤醒等待在对象监视器上的所有线程。它会唤醒所有等待的线程，让它们竞争重新获取对象的监视器。

因此，主要区别在于：

- notify()只能唤醒一个线程，而notifyAll()可以唤醒所有等待的线程。
- notify()选择性地唤醒等待线程，具体唤醒哪个线程不确定；而notifyAll()会唤醒所有等待的线程，让它们竞争执行。

在使用时，通常建议使用notifyAll()，因为它可以避免一些潜在的线程饥饿（starvation）问题。但是在某些情况下，如果确切地知道哪个线程需要被唤醒，则可以使用notify()方法来针对性地唤醒该线程。

## CountDownLatch、CyclicBarrier、Semaphore的区别

CountDownLatch、CyclicBarrier和Semaphore都是Java中用于多线程编程的工具类，它们主要用于协调多个线程之间的操作，以达到有效管理线程的目的。虽然这三个类的作用有一些相似，但其实它们之间还存在一些区别。

CountDownLatch（倒计时器）
CountDownLatch被用来等待一个事件或者多个事件发生后才执行某些操作，即它可以使某个线程一直等待，直到其他线程都执行完毕，再开始执行该线程的任务。CountDownLatch通过一个计数器来实现，计数器初始值为线程总数，每当一个线程完成了自己的任务后，计数器的值就会减一，当计数器的值为0时，表示所有线程都已完成任务，然后在等待的线程就会被唤醒。

CyclicBarrier（屏障）
CyclicBarrier也是Java中的一个同步辅助类，它可以使得一组线程达到一个屏障（也可以叫做同步点）时被阻塞，直到最后一个线程到达屏障时，所有被阻塞的线程才能继续执行。不同于CountDownLatch一次性的减少计数器数量，CyclicBarrier的计数器在达到0之后会重置。

Semaphore（信号量）
Semaphore是用来控制同时访问某个资源的线程数量，它通过一个计数器来实现，如果在初始化Semaphore时指定了许可的数量，那么多个线程就可以同时执行该代码，并且在使用该资源之后释放许可，这样其他被阻塞的线程才能够继续访问该资源。

总的来说，虽然这三个工具类都可以协调多个线程之间的操作，但是它们的使用场景和机制并不完全相同。CountDownLatch适用于等待一组线程全部结束后再执行某个任务的场景，CyclicBarrier适用于等待一组线程全部到达一个屏障后再执行某个任务的场景，而Semaphore则适用于控制对某个资源的访问量的场景。

## Java的几种锁应用的场景分别是什么？

在 Java 中，常见的锁包括 synchronized、ReentrantLock 和 ReadWriteLock 等。它们应用于不同的场景，下面是它们的具体应用场景：

synchronized：synchronized 是 Java 语言的内置锁，适用于需要对共享资源进行加锁和解锁的场景。synchronized
使用起来简单方便，并且可以保证线程安全，但缺点是可扩展性较差，只能支持非公平锁，并且容易出现死锁问题。

ReentrantLock：ReentrantLock 是一个可重入锁，可以重复进入由同一线程持有的任何锁，适用于需要支持公平锁和非公平锁，并且需要更好的可扩展性和更精细的线程交互控制的场景。相比
synchronized，ReentrantLock 提供了更多的功能，例如支持可中断锁和超时锁等特性，但使用起来也更为复杂。

ReadWriteLock：ReadWriteLock 是一种读写锁，用于支持对共享资源的读取和写入操作，适用于读多写少的场景。与普通锁不同，ReadWriteLock
支持多个线程同时读取共享资源，但只允许一个线程进行写入操作。这样可以提高并发性能，减少线程竞争，同时保证数据的一致性。

## volatile关键字的应用场景是什么？

在 Java 中，volatile 是一种关键字，用于修饰变量。当一个变量被 volatile 修饰时，它会具有以下两个特性：

- 可见性：当一个线程修改了一个被 volatile 修饰的变量时，这个变化对其他线程是可见的。

- 禁止指令重排：编译器和处理器不能对被 volatile 修饰的操作进行优化和指令重排。

volatile 的应用场景主要包括：

- 在多线程环境下保证变量的可见性：在多线程环境下，常常需要通过共享变量来实现线程间的通信。如果不加任何同步措施，不同线程之间无法保证对变量的可见性，从而导致数据的不一致性。使用 volatile
  可以确保变量的修改对其他线程是可见的，从而避免出现数据不一致问题。

- 作为一种轻量级的同步机制：相比于 synchronized 和 Lock 等同步机制，volatile 更为轻量级，可以减少线程之间的阻塞和上下文切换。因此，当需要保证变量的可见性时，如果加锁的代价过于昂贵，可以考虑使用
  volatile。

需要注意的是，volatile 不能替代 synchronized，它只能保证变量的可见性和禁止重排，但无法保证原子性。如果需要同时保证可见性、原子性和有序性，还需要使用 synchronized 或者 Lock 等同步机制。

## 什么场景下应该使用原子性同步？

原子性同步是指在多线程环境下，保证某个操作的原子性和可见性。Java提供了多种原子性同步的类，例如 AtomicInteger、AtomicLong 等。通常，应该使用原子性同步的场景包括：

- 计数器场景：当需要对一个变量进行自增或自减操作时，可以使用原子性的 AtomicInteger 或 AtomicLong 来保证操作的原子性和可见性，从而避免多个线程对同一个变量的竞争问题。

- 缓存场景：当需要实现一个高效的缓存系统时，可以使用 AtomicReference 或 AtomicReferenceArray
  等原子性同步的类来保证缓存数据的原子性和可见性。这样可以避免出现多个线程对同一个缓存区域的竞争问题，并提高缓存的并发能力。

- 无锁算法场景：在一些需要实现无锁算法的场景中，例如 CAS 操作等，可以使用原子性同步的类来保证操作的原子性和可见性，并避免出现死锁等问题。

总之，当需要在多线程环境中保证操作的原子性和可见性时，应该使用原子性同步的类，以避免线程间的竞争问题，并提高应用程序的并发处理能力。但需要注意的是，过度使用原子性同步可能会造成性能问题，需要根据实际情况进行选择和权衡。

## Java的集合、Map在什么时候会出现线程安全问题？有什么解决方案？

Java的集合和Map是常用的数据结构，但是在多线程环境下，如果不进行合适的同步处理，可能会出现线程安全问题。常见的线程安全问题包括：ConcurrentModificationException 异常、数据不一致等。

以下是一些可能导致线程安全问题的场景：

- 遍历操作：在遍历集合或Map时，在另一个线程修改集合或Map容器的情况下，可能会抛出并发修改异常。

- 并发修改操作：在多个线程同时修改集合或Map容器时，可能会导致数据不一致等线程安全问题。

为了解决这些问题，Java提供了多种线程安全的集合和Map实现类，例如：

- ConcurrentHashMap （线程安全的Map实现类）：它使用锁分段技术（Segment）来减小锁的粒度，从而提高并发能力。

- CopyOnWriteArrayList 和 CopyOnWriteArraySet （线程安全的List和Set实现类）：每次修改都会复制出一个新的数组来，保证线程安全。

- Collections.synchronizedXXX 方法：可以使用该方法对集合或Map进行同步处理，使其具备线程安全性。该方法使用synchronized关键字对整个容器对象进行加锁，从而保证线程安全。

## 多个线程同时对ArrayList、HashMap进行修改，如增加或删除元素时，为什么会出现线程安全问题？

当多个线程同时对ArrayList或HashMap进行修改时，可能会导致以下两种情况：

- 内存不一致问题
  多个线程同时修改ArrayList或HashMap时，由于内部实现并非是线程安全的，在多线程并发修改时，可能会出现数据不一致的情况。例如，某个线程在增加或删除元素时，可能没有及时更新集合的长度或哈希表的结构，在其他线程取值时，可能会得到错误的结果。

- 并发修改异常
  当一个线程正在遍历ArrayList或HashMap时，另一个线程进行修改操作，例如增加或删除元素，就会导致集合或哈希表结构发生变化，从而使当前正在遍历的线程抛出ConcurrentModificationException异常。

## 根据index查找数组元素时，为什么时间复杂度为O(1)

- 数组在内存中是一段连续的内存空间，元素的存储位置是相邻的。因此，通过索引访问元素时，只需要知道该元素在内存中的起始地址和元素类型的大小，就可以直接计算出元素的存储位置，从而以O(1)的时间复杂度完成元素的访问。

- 数组的每个元素可以通过下标直接访问，只需要乘以每个元素的大小。

因此，如果已知数组的起始地址和元素类型的大小，就可以通过简单的数学计算得到索引对应的元素地址，从而以O(1)的时间复杂度完成元素的访问。这也是数组索引访问的优势所在。

## CopyOnWriteArrayList通过什么方式实现线程安全？

写时复制

## Java的线程池有哪些参数？他们的作用分别是什么？

- Java的线程池（ThreadPoolExecutor）提供了一些参数，用于控制线程池的行为和性能。以下是线程池的一些常用参数及其作用：

- corePoolSize（核心线程数）：指定线程池中保留的核心线程数量。即使这些线程当前处于空闲状态，它们也不会被销毁。当有任务提交时，核心线程会立即执行。

- maximumPoolSize（最大线程数）：指定线程池中允许存在的最大线程数量。当工作队列已满且活动线程数小于最大线程数时，线程池会创建新的线程来执行任务。

- keepAliveTime（线程空闲时间）：指定非核心线程的空闲时间。当线程池中的线程数量超过核心线程数，并且这些非核心线程空闲时间超过keepAliveTime时，这些线程会被回收。

- unit（时间单位）：用于设置keepAliveTime的时间单位，如TimeUnit.SECONDS。

- workQueue（工作队列）：用于存储还未执行的任务的阻塞队列。线程池根据内部策略从工作队列中获取待执行的任务。

- threadFactory（线程工厂）：用于创建新线程的工厂。可以自定义线程的创建过程，例如设置线程的名称、优先级等。

- handler（拒绝策略）：当线程池已达到最大线程数且工作队列已满时，新任务将无法提交到线程池。拒绝策略用于定义如何处理无法提交的任务。常见的策略包括抛出异常、在调用者线程中执行任务、丢弃任务或丢弃队列中最旧的任务。

通过合理配置这些参数，可以根据实际业务需求来优化线程池的性能和资源消耗。核心线程数、最大线程数、工作队列类型以及拒绝策略等都是需要根据具体情况进行调整的参数。

## 核心线程数和最大线程数一般为多少？

- 核心线程：

CPU密集型：核心线程数=CPU核心数(或 核心线程数=CPU核心数+1)。

I/O密集型：核心线程数=2*CPU核心数（或 核心线程数=CPU核心数/（1-阻塞系数))。

- 最大线程：

CPU密集型应用，最大线程设置为 N+1。

IO密集型经验应用，最大线程设置为 2N+1 (N为CPU数量，下同)。

## 现在有这样的一个场景，我们需要给1~10000个用户发邮件，发送邮件需要调用rpc服务并等待响应结果，现在有一台8核16线程的机器以及16G的内存，你应该怎样配置线程池的参数？

- 核心线程数：由于发送邮件是一个网络I/O密集型的任务，执行时间较短，我们可以设置核心线程数为8，与机器的CPU核数保持一致。这样可以避免线程的频繁创建和销毁，提高线程池的效率。

- 最大线程数：根据发送邮件的并发量和系统负载情况，可以将最大线程数适当设置为16或者稍微大于16。这样可以保证有足够的线程资源来处理并发请求，避免任务等待过长的时间。

- 阻塞队列：由于任务是异步执行的，我们可以选择一个适当大小的阻塞队列来缓冲待处理的任务。可以考虑使用有界的阻塞队列，如ArrayBlockingQueue，根据系统的负载情况来确定其大小，以避免任务积压过多导致内存不足。

- 线程超时时间：由于发送邮件需要调用RPC服务并等待响应结果，我们可以设置适当的线程超时时间，以避免线程长时间地等待响应结果而占用线程池资源。可以根据RPC服务的响应时间来调整线程超时时间。

- 其他参数：根据具体情况，还可以考虑设置线程池的拒绝策略，以处理任务队列已满时的情况。可以选择合适的拒绝策略，如CallerRunsPolicy，将任务返回给调用者进行处理。

需要注意的是，在配置线程池参数之前，我们建议先进行测试和评估。可以使用一些并发测试工具模拟实际负载，在不同的并发量和资源情况下观察线程池的性能指标，如平均响应时间、吞吐量等，以找到最优的线程池参数配置。

## 线程的拒绝策略有哪些？实际生产项目中一般用哪种拒绝策略？

Java线程池提供了以下几种常见的拒绝策略：

- ThreadPoolExecutor.AbortPolicy（默认）：当线程池已达到最大线程数且工作队列已满时，新任务的提交将会被拒绝，并抛出RejectedExecutionException异常。

- ThreadPoolExecutor.CallerRunsPolicy：当线程池已达到最大线程数且工作队列已满时，新任务的提交将会由调用线程直接执行。这意味着提交任务的线程将会参与任务的执行，可能会降低整体的处理速度。

- ThreadPoolExecutor.DiscardOldestPolicy：当线程池已达到最大线程数且工作队列已满时，新任务的提交将会直接丢弃最旧的未执行任务，然后尝试再次提交。这种策略可能会导致部分任务被丢失。

- ThreadPoolExecutor.DiscardPolicy：当线程池已达到最大线程数且工作队列已满时，新任务的提交将会直接丢弃，不做任何处理。所有被丢弃的任务将不会被执行。

在实际生产项目中，拒绝策略的选择需要根据具体情况进行权衡和决定。常见的使用方式是根据业务需求合理设置拒绝策略：

- 如果任务提交非常重要，不能容忍任务丢失，一般会选择AbortPolicy，即抛出异常，让调用者知道任务提交被拒绝。

- 如果处理速度相对较慢但要求保证任务不被丢弃，可以选择CallerRunsPolicy，让提交任务的线程参与执行。

- 如果对于旧的未执行任务没有太大的价值，可以选择DiscardOldestPolicy，丢弃最旧的任务，尝试保留新的任务。

- 如果对于被拒绝的任务不做任何处理并且无需通知调用者，可以选择DiscardPolicy，直接丢弃任务。

需要根据具体的业务场景和要求来选择适合的拒绝策略，以达到最佳的效果。

## Java在哪些场景可以使用volatile关键字而不用使用Atomic类？

在Java中，volatile关键字和Atomic类都可以用于实现多线程之间的数据共享和同步。下面是一些场景，在这些场景下可以考虑使用volatile关键字而不用使用Atomic类：

- 单一变量的原子性操作：如果只需要对单一的共享变量进行原子性的读写操作，而不需要复合操作（例如递增、递减等），那么volatile关键字就足够了。例如：

```java
private volatile int counter;
// ...
counter++; // 只需要保证counter的可见性，不需要原子性操作
```

- 简单的标志位控制：在某些场景下，只需要用一个布尔标志来控制并发行为，而不需要具体的数值操作。volatile关键字可以确保可见性，并且在某些特定情况下也可以实现一定的原子性。例如：

```java
private volatile boolean flag;
// ...
if(flag){
// 执行某些操作
}
```

需要注意的是，虽然volatile关键字可以保证可见性，但不能保证原子性。如果在复合操作（例如复合赋值、递增、递减等）上需要保证原子性，则应该考虑使用Atomic类，如AtomicInteger、AtomicLong等。

另外，值得一提的是，volatile关键字对于一些复杂的操作，例如读-修改-写的原子性操作、懒加载等，并不能提供足够的保证，此时仍然需要考虑使用Lock或者Atomic类。

综上所述，在简单的变量操作和标志位控制的场景下，可以考虑使用volatile关键字。在需要实现更复杂的原子性操作时，应该优先考虑使用Atomic类。

## 既然volatile能保证内存的可见性，为什么它无法保证原子性呢？

虽然volatile关键字可以保证变量的可见性，但它无法保证原子性的主要原因是：volatile关键字仅保证了对变量的读写操作的可见性，但在多线程环境下，复合操作可能涉及到多个读写步骤，而volatile关键字无法保证这些读写操作的原子性。

下面是一个简单的例子来说明volatile关键字无法保证原子性的问题：

```java
private volatile int counter=0;

public void increment(){
        counter++; // 非原子操作
        }
```

在该示例中，虽然counter变量使用了volatile关键字，可以保证每次对counter的读取和写入都是可见的，但是counter++操作实际上包括了读取、增加和写入三个步骤。如果多个线程同时执行increment方法，就有可能导致竞态条件，导致并发问题，例如两个线程同时读取counter的值为10，然后进行自增操作，最后写回counter时都变成了11。

对于需要保证原子性的操作，可以使用Atomic类（如AtomicInteger、AtomicLong等）或者使用锁（如synchronized、ReentrantLock等）来实现。这些机制提供了更强大的原子性保障，可以实现多个线程之间的互斥访问，从而确保操作的原子性。

总结起来，volatile关键字只能保证可见性，但无法保证复合操作的原子性。如果需要保证原子性的操作，应该考虑使用其他机制，如Atomic类或锁机制。

## Atomic类怎么避免ABA问题？

用时间戳作为版本号（或称为标记）来跟踪变量的变化

## ThreadLocal为什么要用弱引用？

ThreadLocal为什么要使用弱引用主要是为了避免内存泄漏。让我们先了解一下ThreadLocal的工作原理。

ThreadLocal是Java中一种线程级别的变量容器，它提供了线程局部变量的功能。每个ThreadLocal对象都可以存储一个线程私有的变量副本，不同线程之间互不干扰。ThreadLocal内部使用ThreadLocalMap来存储数据，其中键为ThreadLocal实例，值为线程私有的变量。

正常情况下，当线程终止时，由于没有对ThreadLocal对象的引用，ThreadLocalMap中与该线程相关联的键值对会被垃圾回收，从而释放资源。然而，如果ThreadLocal对象被其他地方持有强引用，并且没有及时清理，就会导致ThreadLocalMap中的键无法被正确回收，从而可能导致内存泄漏。

为了解决这个问题，ThreadLocal在设计时选择使用弱引用来持有ThreadLocal对象。弱引用在垃圾回收时比较脆弱，当对象只被弱引用引用时，在垃圾回收过程中会被自动回收。这意味着如果没有其他地方持有ThreadLocal对象的强引用，即使ThreadLocal对象被垃圾回收，对应的键值对也会被正确清理，避免内存泄漏。

弱引用的使用还带来了一个优势，可以减少处理线程终止后遗留下来的键值对的开销。由于ThreadLocalMap中的键是弱引用，当线程终止时，不需要手动清理对应的键值对，垃圾回收会自动处理。

需要注意的是，虽然ThreadLocal使用弱引用可以帮助避免内存泄漏，但仍需注意合理使用ThreadLocal，及时清理不再需要的ThreadLocal对象，以免占用过多的内存资源。

## 多线程惊群效应是什么意思？

多线程惊群（Thread Wake-Up Problem），也称为惊群效应，是指在某些并发编程场景下，当一个线程被唤醒时，可能会导致其他等待中的线程也同时被唤醒，从而引发一系列性能问题。

具体来说，当多个线程等待同一个资源或条件时，例如等待某个锁的释放或等待某个条件满足，如果其中一个线程获得了所需的资源或条件，并且通过通知（notify）或唤醒（wake-up）操作将其他线程唤醒，那么这些被唤醒的线程就同时争夺相同的资源。

这种情况下，由于所有的线程都同时竞争同一个资源，会引发激烈的竞争和上下文切换，造成额外的开销和性能下降。除此之外，还可能会引发其他问题，如饥饿、死锁等。

多线程惊群效应的出现可以是由于设计不恰当、竞态条件导致的，也可能是底层操作系统或线程调度机制的特性所导致的。惊群效应并非总是发生，它在特定的并发环境和条件下才会出现。

为避免多线程惊群效应，可以采取一些策略，如合理的线程唤醒机制、使用粒度更细的锁、引入随机性等。具体的解决方案需要根据具体的场景和问题进行设计和实施。

## Java8提供了哪些函数式编程？

Java 8引入了许多函数式编程的特性和函数式接口，以支持更为灵活和简洁的代码编写。以下是Java 8提供的一些主要的函数式编程功能：

- Lambda表达式：Lambda表达式是函数式编程的核心概念之一。它允许我们将函数作为参数传递给其他方法，并在需要时创建匿名函数。Lambda表达式使用箭头操作符"->"来分隔参数列表和函数体。

- 函数式接口：Java 8引入了一些新的函数式接口，如Predicate、Consumer、Function、Supplier等，这些接口提供了常用的函数式编程操作，如条件判断、数据处理、转换等。

- 方法引用：方法引用（Method Reference）是Lambda表达式的一种简化写法，它可以直接引用已有的方法，提供了更加简洁的代码写法。例如，可以使用对象的实例方法引用 object::method 或者类的静态方法引用
  ClassName::staticMethod。

- Stream API：Stream API是Java 8新增的一个处理集合数据的API，它提供了一种流式操作的方式，能够以声明式的方式对集合进行过滤、映射、排序、归约等操作，使代码更加简洁优雅。

- Optional类：Optional类是Java 8引入的一个容器类，用于解决空指针异常。它可以包装一个可能为null的值，并提供了一系列的操作方法，如获取值、判断是否为空、如果为空则执行默认操作等。

- 默认方法（Default Method）：Java 8允许在接口中定义默认方法，即拥有方法体的接口方法。这样做的目的是为了向已有的接口添加新的方法，而不会破坏原有的实现类。

- 函数式编程库：Java 8提供了一些函数式编程相关的库，如java.util.function包下的函数式接口、java.util.stream包下的Stream API等，以支持更丰富的函数式编程操作。

这些函数式编程功能的引入使得Java在编写代码时更加灵活、简洁和易读，并且能够使用函数式风格处理集合等数据，提高开发效率和代码质量。

## Java8的函数式接口Predicate、Consumer、Function、Supplier有什么用？它们的优缺点分别是什么？

Java 8的函数式接口Predicate、Consumer、Function和Supplier分别用于不同的函数式编程场景，它们具有以下用途和特点：

- Predicate（断言型接口）：

    - 用途：Predicate接口用于判断一个输入参数是否满足特定条件，返回一个布尔值。
    - 优点：可以通过Lambda表达式实现复杂的条件判断逻辑，方便进行筛选、过滤等操作。
    - 缺点：在某些情况下，可能需要定义多个Predicate接口实例来完成多个条件的组合。
- Consumer（消费型接口）：

    - 用途：Consumer接口用于处理一个输入参数，并根据需要执行某些操作，没有返回值。
    - 优点：可以对输入参数进行任意操作，例如打印、修改等，适用于一些需要执行副作用的场景。
    - 缺点：无法获取方法执行的结果，如果需要得到方法的返回值，可能需要结合其他函数式接口一起使用。
- Function（函数型接口）：

    - 用途：Function接口用于将一个输入参数映射为另一个结果，可以有输入参数和输出参数，常用于数据的转换和处理。
    - 优点：可以根据输入参数的类型和需求，自由组合、链式调用多个Function接口实例，实现复杂的数据变换。
    - 缺点：在某些情况下，可能需要定义多个Function接口实例来完成多个转换操作，会增加代码的复杂性。
- Supplier（供给型接口）：

    - 用途：Supplier接口用于生成一个结果，不需要任何输入参数。
    - 优点：适用于需要动态生成值或对象的场景，延迟计算，提高性能和资源利用率。
    - 缺点：无法处理需要依赖外部数据或状态的场景，只能生成固定的结果。

总的来说，这些函数式接口大大简化了函数式编程的代码编写，提供了灵活、可组合的操作方式。它们能够在处理集合、过滤、映射、转换等场景中发挥作用。优点是可以实现复杂的逻辑、减少样板代码，并支持链式调用和组合操作；缺点是可能需要定义多个接口实例来完成复杂操作，或者某些情况下无法满足特定需求。

## Java怎样检测死锁？检测到了死锁怎么修复？
在 Java 中，可以使用线程管理接口 ThreadMXBean 的 findDeadlockedThreads() 方法检测死锁。该方法返回一个包含所有死锁线程 ID 的 long 数组，如果不存在死锁，则返回 null。

以下是通过 ThreadMXBean 检测和修复死锁的一般步骤：

获取 ThreadMXBean 实例：
```java
ThreadMXBean threadMxBean = ManagementFactory.getThreadMXBean();
调用 findDeadlockedThreads() 方法检测死锁：
java
long[] deadlockedThreadIds = threadMxBean.findDeadlockedThreads();
判断是否有死锁发生：
java
if (deadlockedThreadIds != null) {
// 检测到死锁，执行相应的处理逻辑
// ...
} else {
// 没有检测到死锁，继续正常执行程序
// ...
}
```
修复死锁：

修复死锁的方法因情况而异，通常有以下几种常见的修复策略：

- 调整锁的获取顺序：尝试修改代码，以保证线程获取锁的顺序始终按照相同的顺序，避免循环等待的情况。
- 使用 tryLock() 替换 synchronized：将 synchronized 关键字替换为可重入锁（如 ReentrantLock），并使用 tryLock() 方法来获取锁，可以设置超时时间，并在超时后进行相应的处理。
- 中断死锁线程：对于检测到的死锁线程，可以尝试中断其中一个或多个线程，打破死锁状态。注意要谨慎处理线程中断，在终止线程后还需要进行相应的资源释放和清理工作。

修复死锁需要根据具体情况灵活操作，具体的解决方案可能因代码结构、业务逻辑等而异。当发生死锁时，可以使用相关工具（如 Arthas）来定位问题，观察堆栈信息、锁持有情况等，帮助分析死锁原因并找到合适的修复方案。

## synchronized关键字怎样实现锁升级？
在Java中，synchronized关键字可以用于实现简单的锁机制。锁升级是指在多线程环境下，从较低级别的锁转换为更高级别的锁，以提高性能和并发性。在synchronized关键字中，锁升级有以下几种形式：

- 偏向锁（Biased Locking）：当只有一个线程访问同步代码块时，会使用偏向锁。线程获取偏向锁后，之后再次进入同步代码块时不需要进行额外的加锁操作，提高了性能。

- 轻量级锁（Lightweight Locking）：当多个线程竞争同步代码块时，偏向锁会升级为轻量级锁。轻量级锁通过CAS（Compare and Swap）操作来实现锁定和解锁，避免了线程的阻塞和唤醒，提高了并发性能。

- 重量级锁（Heavyweight Locking）：当多个线程竞争同步代码块的时候，轻量级锁会升级为重量级锁。重量级锁采用传统的互斥量机制，在操作系统层面上阻塞和唤醒线程，确保同一时间只有一个线程可以执行同步代码块。

锁升级的过程是自动的，由JVM负责管理。具体而言，当线程进入同步代码块时，JVM首先使用偏向锁进行尝试性加锁，如果失败，则升级为轻量级锁，并通过CAS操作来竞争锁。如果轻量级锁竞争失败，就会膨胀为重量级锁。锁的升级过程是逐步发生的，而不是一开始就决定使用哪种锁。

## synchronized关键字是公平锁吗？
synchronized关键字默认情况下是一种非公平锁。在非公平锁的情况下，线程获取锁的顺序是不确定的，不会考虑等待时间长短，可能会导致某些线程长时间等待。

当一个线程释放锁时，JVM会从等待队列中选择一个等待线程获得锁，并且无法保证等待时间最长的线程优先获取锁。这可能会导致一些线程长期处于饥饿状态，即始终无法获取到锁。

相比之下，公平锁会按照请求锁的顺序，即先到先得的原则，保证所有等待锁的线程都能以公平的方式获得锁。在Java中，ReentrantLock类可以通过构造函数指定是否使用公平锁，默认为非公平锁。

需要注意的是，非公平锁的性能通常比公平锁要高，因为公平锁需要维护等待队列并且按照顺序进行获取锁的操作。在大部分情况下，非公平锁能够提供更高的吞吐量。但在特定场景下，如果对于线程获取锁的顺序有严格要求或者防止饥饿现象的发生，可以选择使用公平锁。

## AQS原理
AQS（AbstractQueuedSynchronizer）的原理是基于一个双向的等待队列和一个整型的状态变量。它采用了经典的CLH（Craig、Landin、Hagersten）锁队列算法来实现线程的等待和唤醒。

AQS的状态变量表示同步资源的状态，它是一个volatile类型的整数，可以通过CAS（Compare and Set）操作来修改。AQS提供了getState()和setState()等方法来获取和设置状态变量的值。

AQS的等待队列是一个双向链表，节点（Node）表示一个等待线程，每个节点维护了前驱节点（predecessor）和后继节点（successor）。AQS提供了enq(Node)和deqAndWake()等方法来进行节点的入队和出队操作。

AQS的核心是通过acquire(int)和release(int)方法来协调多线程对共享资源的访问。当一个线程需要获取共享资源时，它会调用acquire(int)方法，该方法会尝试获取资源，如果成功则继续执行，否则将当前线程包装成一个节点加入等待队列并进行自旋等待。

在等待队列中，每个节点都有一个状态（状态变量的一部分），用于表示线程的等待状态。例如，等待状态可以是独占模式（exclusive mode）或共享模式（shared mode）。

当一个线程释放资源时，它会调用release(int)方法，该方法会释放资源并唤醒等待队列中的后继节点。唤醒的线程会再次尝试获取资源，如果成功则继续执行。

AQS的锁队列算法实现了公平性和非公平性两种模式。在公平模式下，线程的获取和释放资源按照FIFO（先进先出）的顺序进行，并且不会出现线程饥饿的情况。在非公平模式下，线程的获取和释放资源不保证按照特定的顺序，可以优先考虑获取资源的线程，从而提高吞吐量。

通过AQS，开发者可以方便地构建自定义的同步器，灵活地实现各种并发控制机制，如独占锁、共享锁、倒计时门栓等。AQS提供了底层的基本操作和状态管理，简化了同步器的实现过程，并提供了高效的线程调度机制，使得多线程程序能够以高效且安全的方式协同工作。

## Java的乐观锁和悲观锁有哪些？
在 Java 中，乐观锁（Optimistic Locking）和悲观锁（Pessimistic Locking）是两种常见的并发控制机制。

- 乐观锁： 乐观锁假设并发操作之间很少会发生冲突，因此在读取数据时不会加锁，而是在更新数据时进行并发冲突的检测。如果发现冲突，会回滚事务或者重新尝试更新操作。乐观锁通常使用版本号（Versioning）或时间戳（Timestamp）来实现。常见的乐观锁实现有：

版本号机制：为每条记录添加一个版本号字段，更新时比较版本号是否一致。

时间戳机制：记录最后更新时间，更新时比较时间戳是否一致。

- 悲观锁： 悲观锁假设并发操作之间会发生冲突，因此在读取数据时会加上锁，阻止其他线程对数据进行修改，直到当前线程完成操作释放锁。悲观锁适用于并发写操作较多的场景。常见的悲观锁实现有：

synchronized：使用关键字 synchronized 对代码块或方法进行加锁。

ReentrantLock：java.util.concurrent 包下提供的可重入锁，通过 acquire() 和 release() 方法实现加锁和释放锁的操作。


# JVM

## jvm在什么情况下会进行full gc

JVM会进行full GC主要有以下几种情况：

当eden区满了，新创建的对象没有足够的空间分配时，会触发一次Minor GC，此时存活下来的对象会被复制到survivor区，如果survivor区已经满了，则会将对象放入老年代中。当老年代也满了时，就会触发一次Full GC。

当永久代（Perm Gen）满了，JVM会触发Full GC来进行回收。

当调用System.gc()方法时，JVM会尝试进行Full GC。

当堆大小限制达到了最大值（-Xmx），JVM会尝试进行Full GC。

当应用程序调用了大量的System.gc()方法，或者频繁地创建大量临时对象时，可能会导致Full GC的触发。

总之，Full GC是一种非常耗费系统资源的操作，应该尽量避免触发。

## jvm在什么情况下会进行young gc

JVM会进行young gc主要有以下几种情况：

当Eden区（年轻代）满了，JVM会触发一次Young GC。这时候存活下来的对象会被复制到Survivor区（幸存者区），如果Survivor区也满了，就会将对象放入老年代中。

当Survivor区满了，JVM会触发一次Young GC。这时候存活下来的对象会被复制到另外一个Survivor区中，如果两个Survivor区都满了，就会将对象放入老年代中。

当对象的年龄达到一定值时，就会晋升到老年代中。这个年龄默认是15，可以通过JVM参数-XX:MaxTenuringThreshold来调整。

当老年代满了，JVM会进行Full GC。这时候，年轻代和老年代都会被GC，因此也会对年轻代进行Young GC。

总之，Young GC是一种频繁进行的GC操作，但是它比Full GC消耗的资源要少得多，因此尽可能地让对象在年轻代中被回收，可以提高应用程序的性能。

jvm的Survivor1区和2区的区别是什么？为什么大小比例是1:1?
JVM中的Survivor区是一个用于存放新生代对象的区域，它被划分为两个部分：Survivor1区和Survivor2区。这两个区域的作用是相同的，它们都用于存放新生代存活下来的对象。

Survivor1区和Survivor2区的大小比例通常是1:
1。这是因为，在垃圾回收过程中，JVM会将某个Survivor区中存活的对象复制到另一个Survivor区中，同时清空原Survivor区。如果两个Survivor区大小不一致，那么复制过程会非常复杂。而且，如果一个Survivor区非常小，那么其中的对象很可能无法得到充分的利用，从而导致频繁的垃圾回收，影响性能。因此，通常设置Survivor1区和Survivor2区的大小比例为1:
1，保证它们能够充分利用，同时也方便垃圾回收过程的实现。

## 导致full gc的原因有哪些？通过什么方式可以检测到？需要调整什么参数？

- 通常是由以下几个常见原因引起的：

    - 内存不足：当堆内存不足以容纳所有活动对象时，垃圾回收器会触发 Full GC 来清理整个堆空间。

    - 长时间存活的对象：如果有大量长时间存活的对象存在，垃圾回收器可能需要进行 Full GC 来清理这些对象。

    - 晋升失败：当新生代中的对象无法在多次 Minor GC 后晋升到老年代时，将触发 Full GC。

    - 永久代/元空间满：永久代（Java 8 之前）或元空间（Java 8+）用于存储类定义和常量池等信息，当其中的内容无法被回收时，可能触发 Full GC。

- 为了检测 Full GC 的发生，可以使用以下方式：

    - 查看 GC 日志：通过配置 JVM 的 -verbose:gc 参数，可以在应用程序运行时输出 GC 日志。在日志中，可以查看到 Full GC 的发生以及相关的信息。

    - 使用监控工具：使用诸如 JVisualVM、Grafana、Prometheus 等监控工具来实时监测垃圾回收情况，包括 Full GC 的发生次数和持续时间等指标。

- 针对 Full GC，可以考虑以下参数调整和优化：

    - 堆内存分配：通过调整 -Xmx 和 -Xms 参数来增加堆内存大小，以减少频繁 Full GC 的触发。

    - 新生代大小：通过调整新生代的大小，即 -XX:NewSize 和 -XX:MaxNewSize 参数，来适应对象的生命周期和晋升频率。

    - GC 算法选择：根据应用程序的特点和需求，选择适合的 GC 算法。例如，G1 GC 在大堆内存和低延迟要求下表现较好，而 CMS GC 适用于响应时间敏感的应用。

    - 持久代/元空间调整：如果使用的是 JDK 8 之前的版本，可以通过调整永久代大小（-XX:MaxPermSize）或元空间大小（-XX:MaxMetaspaceSize）来避免 Full GC。

需要注意的是，对于 Full GC 的优化需要综合考虑应用程序的特征和环境情况，并进行反复测试和观察。还可以使用一些工具来分析和优化垃圾回收行为，如GCViewer、GCEasy 等。同时，也建议参考相关的 JVM
文档和优化指南，深入了解每个参数的含义和影响。

## jvm性能监控常用的命令有哪些？

在 JVM 性能监控中，常用的命令工具包括 jstat、jmap、jstack、jcmd、jvisualvm 等。下面逐一介绍这些常用的 JVM 性能监控命令及其用途：

jstat：可用于监控虚拟机的各种运行时状态，如垃圾回收、类加载、JIT 编译等。常用选项包括：

- -gc：用于显示垃圾回收相关的统计信息，如堆内存使用情况、垃圾回收时间等。
- -class：展示类加载和卸载相关的数据，包括类加载数量和卸载数量。
- -compiler：显示 JIT 编译器相关的统计信息，如编译任务数量、编译耗时等。

jmap：用于生成虚拟机的堆转储快照（Heap Dump）文件，以及查看堆内存的详细信息。常用选项包括：

- -heap：显示堆内存的详细信息，包括堆大小、使用情况等。
- -histo：显示堆内存中各个类的实例数量和大小统计信息。
- -dump：生成堆转储快照文件，用于分析内存泄漏和对象分布等问题。

jstack：生成虚拟机的线程转储快照（Thread Dump）文件，以及查看线程的状态和调用栈信息。常用选项包括：

- -F：当正常情况下无法获取线程转储时，使用强制模式进行转储。
- -l：显示关于锁的附加信息。
- -m：显示关于 Java 和本地方法的堆栈帧信息。

jcmd：用于向正在运行的 Java 进程发送诊断命令，如线程转储、垃圾回收等。常用命令包括：

- Thread.print：打印线程转储。
- GC.run：强制进行一次垃圾回收。
- VM.flags：显示和修改虚拟机的运行时参数。

jvisualvm：图形化地监控、分析和调优 Java 应用程序。该工具提供了丰富的插件和功能，可以查看线程状态、内存使用、CPU 负载等信息，并进行性能分析和故障排除。

这些命令都是非常强大且常用的 JVM 性能监控工具，可以帮助开发人员分析和解决应用程序性能问题。每个命令都有各自的选项和用法，可以通过在命令行中键入命令名和 -help
参数来获取详细的使用帮助和示例。此外，还可以结合各种第三方监控工具和分析器，如VisualVM、Mission Control、Grafana 等来进一步深入分析和优化 JVM 性能。

## 怎样判断jvm里是否发生了内存泄露？怎样回收被泄露的内存？

- 判断 JVM 是否发生了内存泄漏可以采取以下方法：

监测堆内存使用：观察 JVM 运行时的堆内存使用情况，如果在长时间运行过程中，堆内存占用不断增加而没有明显的回收释放，则可能存在内存泄漏。可以使用工具如 jstat、jvisualvm 等进行实时监测。

频繁的 Full GC：观察垃圾回收日志和 JVM 的垃圾回收统计信息，如果频繁出现 Full GC（Full Garbage Collection），说明垃圾收集器在做大量的回收操作，可能暗示着内存泄漏问题。

内存溢出错误（OutOfMemoryError）：如果在运行时出现内存溢出错误，例如 Java Heap Space 或 PermGen Space，可能意味着一些对象无法被垃圾收集器释放，提示存在内存泄漏。

- 回收被泄露的内存可以通过以下步骤：

定位内存泄漏源：使用性能分析工具，如 jmap、jvisualvm、MAT（Eclipse Memory Analyzer Tool）等，分析堆转储快照并查找内存泄漏源。注意检查是否存在对于不再使用的对象或资源的持有。

修复代码问题：根据内存泄漏的定位，检查代码中的问题，并修复引发内存泄漏的代码。常见问题包括未及时释放资源、缓存管理不当、对象生命周期管理错误等。

显式释放资源：确保在对象不再使用时显式地释放占用的资源，例如关闭文件、数据库连接、网络连接等。可通过 try-finally 或 try-with-resources 语句块来确保资源的正确释放。

对象引用清除：检查代码中的对象引用是否超出了其有效生命周期，尽早将不再使用的对象引用置为 null，以便让垃圾收集器回收相应的内存。

使用弱引用或软引用：某些场景下，可以使用弱引用（Weak Reference）或软引用（Soft Reference）来引用可能被释放的对象，让垃圾收集器根据引用的强度进行回收。

循环引用处理：如果存在对象之间的循环引用，可以考虑采用弱引用、软引用或使用其他手段打破循环引用关系，以便让垃圾收集器正确回收这些对象。

请注意，内存泄漏问题的解决往往需要综合分析和调试，因为不同的场景和代码片段可能导致不同类型的内存泄漏。及早发现和解决潜在的内存泄漏问题可以提高应用程序的性能和稳定性。

## cms垃圾回收器有什么优缺点？怎么解决缺点？
CMS（Concurrent Mark Sweep）是一种使用并发标记和清除算法的垃圾回收器。它主要用于减少应用程序的停顿时间，但也存在一些优缺点。

优点：

- 垃圾回收期间的停顿时间较短：CMS使用并发标记和清除算法，允许垃圾回收和应用程序并发执行。这可以减少垃圾回收期间的停顿时间，提高应用程序的响应性能。

- 内存占用较低：CMS在标记和清除阶段同时进行，避免了完全停止应用程序运行的暂停时间。这意味着CMS需要较少的内存来存储可达对象的信息，使得应用程序的内存占用较低。

缺点：

- 内存碎片问题：CMS使用标记和清除算法，会产生大量的空闲内存碎片。这可能导致内存分配时无法找到足够的连续空间，从而触发更频繁的内存压缩操作或增加垃圾回收暂停时间。

- CPU占用较高：CMS在执行标记和清除操作时需要消耗一定的CPU资源。由于GC线程和应用程序线程同时执行，可能会导致应用程序的吞吐量下降。

解决CMS垃圾回收器的缺点的方法包括：

- 使用更大的堆内存：通过增加堆内存的大小，可以减少内存碎片问题的发生，并降低垃圾回收频率和停顿时间。但这需要权衡系统资源和应用程序性能之间的关系。

- 设置合适的垃圾回收参数：调整CMS垃圾回收器的参数，如并发线程数、触发垃圾回收的阈值等，可以优化垃圾回收器的性能和行为。根据应用程序的特点和负载情况进行测试和调优。

- 考虑使用其他垃圾回收器：如果CMS在特定场景下无法满足需求，可以考虑使用其他垃圾回收器，如G1（Garbage-First）垃圾回收器。G1垃圾回收器在处理大堆和高并发时表现更好，并能有效解决内存碎片问题。

总之，对于CMS垃圾回收器的缺点，可以通过适当的配置和调优来解决，并可以考虑其他垃圾回收器作为替代方案。选择合适的垃圾回收策略需要根据具体的应用场景和性能要求进行综合评估和测试。

## G1垃圾回收器有什么Bug？为什么java8要用CMS而不用G1
G1（Garbage-First）垃圾回收器是Java平台在Java 7u4版本引入的一种全新的垃圾回收器。尽管G1在许多方面都表现出色，但它也存在一些已知的Bug和限制。

一些G1垃圾回收器的已知Bug和限制包括：

- 处理巨大堆：G1垃圾回收器对于非常大的堆可能会遇到性能问题。由于G1采用了分区算法，处理巨大堆时需要处理大量的分区，这可能导致垃圾回收过程变得更加复杂和耗时。

- 可能引起延迟波动：G1垃圾回收器的目标是减少停顿时间，但在某些情况下，它可能会引起延迟的波动。例如，当垃圾回收进程受到负载或有大量的并发写操作时，G1可能无法实现预期的低延迟。

- 调整参数的复杂性：G1垃圾回收器具有多个可调整的参数，正确地配置这些参数以达到最佳性能并不容易。不正确的参数配置可能导致垃圾回收性能下降、吞吐量降低或产生其他问题。

为什么Java 8选择了CMS而不是G1主要有以下几个原因：

- G1的性能优化需要时间：在Java 8发布时，G1垃圾回收器在处理大堆和高吞吐量方面尚未达到预期的性能水平。而CMS垃圾回收器经过多年的发展和优化，在大多数场景下表现稳定可靠。

- 低停顿时间的需求：对于某些应用程序，低延迟和短暂停顿时间是至关重要的。CMS垃圾回收器采用并发标记和清除算法，可以在较短的停顿时间内完成垃圾回收，适用于对延迟敏感的应用场景。

- CMS的成熟性和稳定性：在Java 8发布时，CMS垃圾回收器已经经过多年的使用和优化，在大型企业级应用程序中被广泛使用并验证了其稳定性和可靠性。

需要指出的是，Java平台不断发展和改进，G1垃圾回收器在后续的版本中进行了许多优化。根据具体的应用场景和性能需求，可以根据实际情况选择合适的垃圾回收器。

## 假设有16G的内存，jvm的新生代、老年代、元空间这些参数该怎么配置？
假设有16GB的内存可用，下面给出一种合理的配置建议，其中新生代、老年代和元空间的内存大小比例为1:2:1。

- 新生代的配置：

  - 可以将新生代的总大小设置为堆内存的三分之一，即约为5.3GB。
  - 可以使用-Xmn参数来指定新生代的总大小，如-Xmn5.3g。

- 老年代的配置：

  - 由于采用了1:2的比例，老年代的大小将是新生代的两倍，即约为10.7GB。
  - 可以通过设置初始堆大小（-Xms）和最大堆大小（-Xmx）为相同的值来固定堆的大小，如-Xms16g -Xmx16g。

- 元空间的配置：

  - 元空间的初始大小可以根据具体应用程序的类数量进行调整。
  - 元空间的最大大小可以设置为一个适当的值，如256MB。
  - 可以使用-XX:MetaspaceSize参数来指定元空间的初始大小，如-XX:MetaspaceSize=256m。
  - 可以使用-XX:MaxMetaspaceSize参数来指定元空间的最大大小，如-XX:MaxMetaspaceSize=256m。

综上所述，可以使用以下JVM参数进行配置：
```java
-Xmn5.3g -Xms16g -Xmx16g -XX:MetaspaceSize=256m -XX:MaxMetaspaceSize=256m
```

这个配置将使得新生代占整个堆内存的1/3，老年代占整个堆内存的2/3，并且元空间的初始大小和最大大小都为256MB。请注意，这只是一种合理的建议，具体的配置还需根据应用程序的需求、硬件环境和性能测试结果进行优化调整。



## Java如何自定义一个类加载器？

Java 中的类加载器（Class Loader）是用于将 Java 类文件加载到 JVM 中并生成对应的 Class 对象的重要组件。在 Java
中，默认提供了三种类加载器：BootstrapClassLoader、ExtensionClassLoader 和 AppClassLoader。如果需要实现特定的需求，比如从指定位置加载类，或者实现代码隔离等，就需要自定义一个类加载器。

以下是自定义类加载器的基本步骤：

- 继承ClassLoader类，重写findClass()方法：继承java.lang.ClassLoader类，通过重写它的protected findClass(String name)方法来完成自定义加载逻辑。

- 实现findClass()方法：在该方法中实现类加载的具体逻辑，此处可以通过文件系统、网络等方式获取字节码，并使用defineClass()方法将字节数组转化为Class对象。

- 覆盖loadClass()方法：覆盖ClassLoader类中的protected loadClass(String name, boolean resolve)
  方法，改变父类加载器的委派机制，逐级向上查找时优先使用自定义类加载器进行加载。

- 创建自定义类加载器对象：创建自定义类加载器的实例，通过重载loadClass方法和findClass方法获得类对象。

下面是一个简单的自定义类加载器实现的示例代码：

```java
public class CustomClassLoader extends ClassLoader {
    @Override
    protected Class<?> findClass(String name) throws ClassNotFoundException {
        byte[] data = getClassData(name);
        if (data == null) {
            throw new ClassNotFoundException();
        }
        return defineClass(name, data, 0, data.length);
    }

    private byte[] getClassData(String name) {
        // 从指定位置读取字节码文件
        // 返回字节数组
        return null;
    }

    @Override
    protected Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException {
        synchronized (getClassLoadingLock(name)) {
            //若类已经被加载，直接返回该类对应的Class对象
            Class<?> c = findLoadedClass(name);
            if (c == null) {
                try {
                    //先使用自定义加载器进行查找
                    c = findClass(name);
                } catch (ClassNotFoundException e) {
                    //如果自定义加载器未加载到，则使用父类加载器进行查找
                    c = super.loadClass(name, resolve);
                }
            }
            if (resolve) {
                resolveClass(c);
            }
            return c;
        }
    }
}
```

需要注意的是，在实现自定义类加载器时，需要考虑很多因素，如命名空间的隔离、安全性、防止字节码篡改等。建议在开发过程中参考相关文档和最佳实践，并进行充分的测试和验证。

## Java的值传递和引用传递有什么区别？

Java 采用的是值传递（Pass-by-Value）的方式，这意味着在方法调用时，实际传递给方法的是变量的拷贝，而不是变量本身。

值传递的特点如下：

- 基本数据类型：对于基本数据类型（如 int、float、boolean 等），传递的是该数据的拷贝副本，即在方法内对参数的修改不会影响到原始变量。

- 引用类型：对于引用类型（如对象、数组等），传递的是该引用的拷贝副本，但这个拷贝指向的是同一个对象。这意味着可以在方法内通过引用修改对象的状态，但对于引用本身的修改不会影响到原始的引用。

要理解这一点，可以将引用看作是指向对象内存地址的一个指针。当我们将引用传递给方法时，实际传递的是该引用的副本，副本也指向同一个对象。因此，在方法内部我们可以通过副本修改对象的内容，但无法通过副本修改原始的引用。

下面通过示例代码来说明值传递和引用传递的区别：

```java
public class PassByValueExample {
    public static void main(String[] args) {
        int num = 10;
        modifyValue(num);
        System.out.println(num); // 输出：10

        StringBuilder sb = new StringBuilder("Hello");
        modifyReference(sb);
        System.out.println(sb.toString()); // 输出：Hello World
    }

    public static void modifyValue(int value) {
        value = 20;
    }
    
    public static void modifyReference(StringBuilder reference) {
        reference.append(" World");
    }
}
```

在上述示例中，modifyValue 方法接受一个基本数据类型的参数，并将其修改为 20。但在 main 方法中打印 num 的值时，仍然是 10，因为在方法调用时传递的是 num 的拷贝。

而对于 modifyReference 方法，它接受一个 StringBuilder 对象的引用，并在原有字符串后追加了 " World"。在 main 方法中打印 sb 对象的值时，会输出 "Hello World"
，因为在方法调用时传递的是 sb 引用的拷贝，但该拷贝仍指向同一个对象，所以对象状态发生了改变。

因此，Java 中虽然传递引用类型的参数时看起来像是引用传递，但实际上依然是值传递。这样的设计可以避免对原始对象的意外修改，同时也更符合 Java 的安全性和可控性。

## 什么情况下需要使用自定义加载器？

在 Java 应用程序中，通常情况下使用默认的系统类加载器是完全足够的。但是，在某些特定的场景中，需要使用自定义的类加载器来满足特定的需求，比如：

- 实现类隔离：当应用程序需要同时运行多个版本的同一个类或者不同的类库时，使用自定义类加载器可以隔离不同版本的类或类库，避免类之间的冲突。

- 动态加载类：某些情况下需要动态地加载类，比如通过网络传输字节码来实现类的动态扩展。

- 加密和解密：为了保护一些关键的 Java 类，可以使用一些加密技术，以自定义的方式加载这些加密的类，从而增强安全性。

- 跟踪类的加载信息： 通过自定义类加载器可以对类的加载过程进行跟踪和记录，便于开发人员进行调试和分析。

需要注意的是，在使用自定义类加载器时需要谨慎对待，要考虑到安全性、版权问题等因素，并进行充分的测试和验证。自定义加载器的开发人员需要具备深入了解 Java 类加载机制及其相关知识的能力和经验。

## Java里static和final static修饰的变量有什么区别？

- 可访问性：static 修饰的变量可以被类的所有实例共享，也可以通过类名直接访问，而不需要创建对象；而 final static 修饰的变量也是共享的，但是它同时具有不可修改的特性。

- 可变性：static 修饰的变量可以被重新赋值多次，它的值可以在程序运行过程中修改；final static 修饰的变量只能被赋值一次，并且不能再被修改，它的值在编译时或运行时就确定了。

- 初始化时机：static 修饰的变量在类加载时初始化，它们的初始化顺序与声明的顺序有关；final static 修饰的变量也是在类加载时初始化，但它必须要在声明时就给定一个初始值。

- 内存占用：static 修饰的变量属于类级别的变量，会在方法区中分配内存；final static 修饰的变量同样也是类级别的变量，也会在方法区中分配内存。它们都不属于实例级别的变量，因此不会为每个对象分配内存。

总之，static 修饰的变量是类级别的共享变量，可以被重新赋值；final static 修饰的变量也是共享变量，但是其值不可修改，只能赋值一次。在实际应用中，可以根据需要选择适合的修饰符来定义变量。

## jvm的符号引用替换为直接引用是什么意思？

在Java的JVM（Java虚拟机）中，符号引用（Symbolic Reference）和直接引用（Direct Reference）是两个概念，它们在类加载、方法调用和内存管理中起到不同的作用。

- 符号引用：符号引用是一种常量池中的数据结构，它用于表示被引用的目标，可以是类名、类的字段、方法等。符号引用并不指向直接的内存地址，而是以符号的形式描述所引用的目标。

- 直接引用：直接引用是指向具体内存地址的指针或者偏移量，它直接定位到内存中的对象、方法等实际位置。通过直接引用，JVM可以快速定位到所引用的目标，并进行相关操作。

将符号引用替换为直接引用是类加载过程中的一个重要步骤，有助于提升运行效率，具体含义如下：

- 类加载时的符号引用转换：在类加载的解析阶段，JVM会根据类文件中的符号引用，通过符号引用所描述的信息，找到对应的直接引用。这个过程称为符号引用解析，解析完成后，符号引用被替换为直接引用，方便后续的访问和调用。

- 方法调用时的符号引用转换：在方法调用的过程中，如果方法的调用目标是一个符号引用，JVM会将其解析为直接引用，即确定该方法所在的位置和实际内存地址，以便直接调用。

- 内存管理中的符号引用转换：在内存管理中，符号引用也需要转换为直接引用。例如，垃圾收集器遍历对象图时，可能会遇到引用关系，这时将符号引用转换为直接引用，可以方便地对对象进行访问和操作。

通过将符号引用替换为直接引用，JVM可以减少符号解析的过程，提高运行效率，同时也节省了额外的内存空间。这种转换过程是在类加载、方法调用和内存管理的不同阶段中发生的，它们共同构成了Java程序的执行环境。

## 创建一个Java对象，需要占用jmm里栈、堆的哪些内存空间
创建一个Java对象时，它在Java内存模型（JMM）中占用了栈和堆中的不同内存空间。

- 栈（Stack）：每个线程在JVM中都有自己的独立栈空间。当一个方法被调用时，JVM会为该方法创建一个称为"栈帧（Stack Frame）"的数据结构，并压入当前线程的栈顶。栈帧中包含了方法的局部变量和方法执行时所需的操作数栈。

在栈中，对象的引用（reference）会被存储在局部变量表（Local Variable Table）中，而不是对象本身。这意味着对象在栈中仅占用了引用所需的内存空间，通常是4字节或8字节，具体取决于JVM的实现。

- 堆（Heap）：Java对象的实例数据（Instance Data）存储在堆中。堆是所有线程共享的内存区域，用于动态分配对象。当我们使用关键字"new"来创建一个对象时，JVM会在堆上为该对象分配一块连续的内存空间，用于存储对象的实例变量。

在堆中，对象占用的内存空间取决于对象的类型和实例变量的数量与类型。Java对象的大小可以通过"对象头 + 实例数据 + 对齐填充"来计算。

总结起来，创建一个Java对象时，它在栈中占用的是对象引用所需的内存空间，而在堆中占用的是对象的实例数据所需的内存空间。栈和堆是JVM中两个不同的内存区域，各自承担着不同的角色和功能。

## alibaba的开源Java诊断工具Arthas有什么用？
- 实时监控：Arthas 可以实时监控 Java 应用程序的运行状态，包括线程、堆栈、方法调用、类加载等信息。通过 Arthas，您可以实时观察应用程序的运行情况，便于定位问题和优化程序。

- 代码热替换：Arthas 支持在运行时动态修改已加载类的字节码，实现代码的热替换。这样您可以在不重新启动应用程序的情况下，修改和调试代码，提高开发效率。

- 方法追踪：Arthas 可以追踪指定方法的调用链，帮助您分析方法的执行过程，查找潜在的性能问题或错误。

- 监控与分析：Arthas 提供了丰富的命令和功能，可以对 Java 应用程序进行监控和分析。例如，您可以查看 JVM 的状态、内存使用情况、GC 日志等；您还可以进行 CPU 分析、线程分析、死锁检测等操作。

- 故障定位：当应用程序出现故障时，Arthas 可以帮助您快速定位问题的根源。您可以通过查看异常堆栈、线程状态、资源使用情况等信息，找到故障的原因，并进行修复。

- 生产环境调优：Arthas 在生产环境中也可以发挥作用。您可以实时监控应用程序的运行状态，查看关键指标，进行性能分析和调优。

## JVM里多大的对象会直接进入老年代？
在Java虚拟机（JVM）中，对象的年龄是通过分代垃圾回收算法来管理的。一般情况下，对象在堆内存中的存活时间越长，就越有可能晋升到老年代。

具体来说，在默认情况下，JVM会根据对象存活的次数和年龄来进行晋升决策。对象在Eden区（新生代的一部分）中出生，经过一次Minor GC后，如果仍然存活，则会被移动到Survivor区。当对象在Survivor区经历了一定次数的存活后，会晋升到老年代。

在不同的JVM实现中，对象晋升到老年代的具体条件可能会有所不同。通常情况下，对象的晋升要满足以下几个条件之一：

- 对象年龄达到阈值：JVM会设置一个阈值，一般为15。当对象在Survivor区存活次数达到阈值时，会被晋升到老年代。

- Survivor区空间不足：当Survivor区无法容纳一些存活对象时，这些存活对象会被直接晋升到老年代，以避免在下一次GC时再次发生晋升。

- 大对象：如果对象的大小超过某个阈值（例如在HotSpot JVM中是-XX:PretenureSizeThreshold参数，默认为0，即关闭此特性），则该对象会被直接分配到老年代。

需要注意的是，具体的晋升条件和阈值可能会因不同的JVM版本、垃圾回收器和调优参数等而有所变化。通过调整JVM的参数，可以对对象晋升行为进行优化和控制。

## 讲一下jvm的内存模型以及创建一个对象分别被存在哪里？
- 程序计数器（Program Counter Register）：程序计数器是一块较小的内存区域，它存储当前线程执行的字节码指令的地址。每个线程都有自己独立的程序计数器，用于控制线程的执行流程。

- Java虚拟机栈（Java Virtual Machine Stack）：每个线程在执行Java方法时都会创建一个栈帧，并将其压入虚拟机栈中。栈帧包含局部变量表、操作数栈、动态链接和方法返回值等。局部变量和方法参数都存储在栈内存中。

- 本地方法栈（Native Method Stack）：本地方法栈类似于虚拟机栈，但它为本地方法服务，而不是Java方法。它存储了使用非Java语言编写的本地方法的信息。

- 堆（Heap）：堆是Java虚拟机中最大的内存区域，用于存储对象实例。所有通过new关键字创建的对象都存储在堆中。堆是被所有线程共享的内存区域，用于动态分配和销毁对象。

- 方法区（Method Area）：方法区用于存储类结构信息、常量、静态变量、即时编译器优化后的代码等。方法区也是被所有线程共享的内存区域。

创建一个对象时，对象本身的数据（实例变量）存储在堆中，而对象的引用（引用变量）存储在栈中或者堆中。如果对象是局部变量，则其引用存储在栈帧的局部变量表中。如果对象是成员变量或数组元素，则其引用可能存储在堆中或者其他对象的实例变量中。

需要注意的是，Java中的对象是通过引用来操作的。当我们使用new关键字创建对象时，JVM会在堆上分配内存来存储对象的实例变量，并将堆中的地址返回给引用变量，从而使我们能够访问和操作对象。
